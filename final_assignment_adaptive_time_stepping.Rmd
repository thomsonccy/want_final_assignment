---
title: "Final assignment: Adaptive Time Stepping"
author: "The WANT team"
date: "19/01/2020"
output:
  html_document:
    css: want.css
    toc: yes
    toc_depth: 1
---


# Introduction
During the exercises on Finite Differences, you have experienced several times that the model can become instable or at least can start oscillating. Often, this could be resolved with decreasing the time step over which the calculation was performed. This is, however, a rather expensive solution, because a smaller time step means many more calculations while maybe, this smaller time step is not needed throughout the complete simulation period. Therefore, adaptive time stepping schemes exist; when needed, a smaller time step is taken, and when not needed, the time step is increased again.  

# The model 
We will implement an adaptive time stepping scheme for the most simple model we dealt with; the emptying reservoir without input. 

![](reservoir_properties.png)



*Single linear reservoir with outlet properties.*  

# First assignment
Implement an adaptive time stepping scheme. For this, you have to define criteria for when the time step has to decrease (and how much). This can be based on the difference between two schemes. However, you don't want to do the same calculation twice, because then you might as well half the step size directly. Therefore, use two schemes where one scheme is an intergral part of the other scheme. The simplest example is Euler Forward and Heun's Method. Heun's Method looks as follows:

$$\widetilde{s}= s(t) + \Delta t f(t,s(t))$$

Where $\tilde{s}$ is a sub-step equal to Euler Forward. Subsequently, $t+\Delta t$ is obtained as:
$$ s(t+\Delta t)= s(t) + \frac{\Delta t}{2}(f(t,s(t))+f(t+\Delta t,\widetilde{s}))$$


Another option is for instance the Cash-Karp method, where two Runge-Kutta schemes are compared. Implement the schemes, define an error tolerance, and adapt the time step when the error exceeds this tolerance. Compare your results to the analytical solution, to evaluate the trade-off between error and number of evaluations-. 

# Second assignment
Conduct a sensitivity analysis. 
- Decide for yourself whether you want to conduct a local or global sensitivity analysis.
- Decide on which parameters you want to conduct sensitivity analysis - the parameters from the reservoir, or the parameters of your adaptive time stepping scheme, or both and their interaction? 

# Further exploration
You are free to explore any other questions that arise with the model. For example:
- Use variable input, such as the Hupsel data from assignment 6, week 1. What are the water balance errors and do these decrease with a variable time stepping scheme? 
- What happens to the results if you add complexity to my model? (e.g. by introducing a second outlet)
- What is the relation between time steps and parameter sensitivity?

$$s(t + \Delta t)=s(t)+\dfrac{\Delta t}{A}
\left(Q_{in}-\alpha_{res.up}(s(t)-level_{res.up})-\alpha_{res.lw}\:s(t)\right)\\$$


```{R}
# Calculate water level in reservoir using Euler Forward and Heun's Method
# Compare the absolute difference between Euler Forward and Heun's Method
# If difference is smaller than tolerance, the result from Heun's method is accepted
# If difference is larger than tolerance, it recalculates using 
# new time step = old time step * factor
# until the difference is smaller than tolerance

calculate_water_level_reservoir = function(state, area, alpha){
  return((-alpha*state)/area)
}

# Function: calculate_euler_forward_method
#
# Purpose:
#   Calculates the next state of the system using the Euler Forward method.
#
# Parameters:
#   state - The current state of the system (numeric).
#   dt    - The time step to be used for calculation (numeric).
#   A     - The area parameter of the reservoir (numeric).
#   alpha - The decay constant (numeric).
#
# Returns:
#   The next state of the system after applying the Euler Forward method (numeric).

calculate_euler_forward_reservoir = function(state, dt, area, alpha) {
    forward = state + dt * calculate_water_level_reservoir(state, area, alpha)
    return(forward)
}


# Function: calculate_heuns_method
#
# Purpose:
#   Calculates the next state of the system using Heun's method.
#
# Parameters:
#   state - The current state of the system (numeric).
#   dt    - The time step to be used for calculation (numeric).
#   A     - The area parameter of the reservoir (numeric).
#   alpha - The decay constant (numeric).
#
# Returns:
#   The next state of the system after applying Heun's method (numeric).

calculate_heuns_reservoir = function(state, dt, area, alpha) {
    s_tilde = state + dt * calculate_water_level_reservoir(state, area, alpha)
    heuns = state + dt / 2 * (calculate_water_level_reservoir(state, area, alpha) + calculate_water_level_reservoir(s_tilde, area, alpha)) 
    return(heuns)
}

#system function
calculate_rk4_reservoir = function(state, dt, area, alpha)
{
        k1 = dt*calculate_water_level_reservoir(state, area, alpha)
        k2 = dt*calculate_water_level_reservoir(state+ k1 / 5, area, alpha) 
        k3 = dt*calculate_water_level_reservoir(state+ 3/40*k1+9/40*k2, area, alpha)
        k4 = dt*calculate_water_level_reservoir(state+3/10*k1-9/10*k2+6/5*k3, area, alpha)
        k5 = dt*calculate_water_level_reservoir(state-11/54*k1+5/2*k2-70/27*k3+35/27*k4, area, alpha)
        k6 = dt*calculate_water_level_reservoir(state+1631/55296*k1+175/512*k2+575/13824*k3+44275/110592*k4+253/4096*k5, area, alpha)
        newstate4 = state + 37/378*k1+250/621*k3+125/594*k4+512/1771*k6
        return(newstate4)
}

calculate_rk5_reservoir = function(state, dt, area, alpha)
{
        k1 = dt*calculate_water_level_reservoir(state, area, alpha)
        k2 = dt*calculate_water_level_reservoir(state+ k1 / 5, area, alpha) 
        k3 = dt*calculate_water_level_reservoir(state+ 3/40*k1+9/40*k2, area, alpha)
        k4 = dt*calculate_water_level_reservoir(state+3/10*k1-9/10*k2+6/5*k3, area, alpha)
        k5 = dt*calculate_water_level_reservoir(state-11/54*k1+5/2*k2-70/27*k3+35/27*k4, area, alpha)
        k6 = dt*calculate_water_level_reservoir(state+1631/55296*k1+175/512*k2+575/13824*k3+44275/110592*k4+253/4096*k5, area, alpha)
        newstate5 = state + 2825/27648*k1+18575/48384*k3+13525/55296*k4+277/14336*k5+1/4*k6
        return(newstate5)
}


# Function: compare_methods
#
# Purpose:
#   Compares the results of the Euler Forward method and Heun's method to determine
#   the difference between these two approaches for a given state and time step.
#
# Parameters:
#   state - The current state of the system (numeric).
#   dt    - The time step to be used for calculation (numeric).
#   A     - The area parameter of the reservoir (numeric).
#   alpha - The decay constant (numeric).
#
# Returns:
#   The absolute difference between the results of the Euler Forward method
#   and Heun's method (numeric).

# compare_methods = function(state, dt=dt, area=A, alpha=alpha) {
#     euler_forward = calculate_euler_forward_method(state, dt, A, alpha)
#     heuns_method = calculate_heuns_method(state, dt, A, alpha)
#     difference = abs(heuns_method - euler_forward)
#     return(difference)
# }

compare_methods_reservoir = function(state, dt, area, alpha, method1, method2) {
    result_method1 = method1(state, dt, area, alpha)
    result_method2 = method2(state, dt, area, alpha)
    difference = abs(result_method1 - result_method2)
    return(difference)
}


# Function: simulate_reservoir
#
# Purpose:
#   Simulates the behavior of an emptying reservoir over a specified time period 
#   using adaptive time stepping.
#
# Parameters:
#   begin_time    - The starting time of the simulation (numeric).
#   end_time      - The ending time of the simulation (numeric).
#   dt_start      - The initial time step for the simulation (numeric).
#   initial_state - The initial state of the reservoir (numeric).
#   area          - The area parameter of the reservoir (numeric).
#   alpha         - The decay constant (numeric).
#   factor        - The factor by which to adjust the time step (numeric).
#   tolerance     - The tolerance level for adjusting the time step (numeric).
#   first_method  - 
#   second_method - 
#
# Returns:
#   A list containing two elements:
#     - time: A vector of time steps at which the state was calculated (numeric).
#     - state: A vector of states of the reservoir at each time step (numeric).

simulate_reservoir = function(begin_time, end_time, dt_start, initial_state, area, alpha, factor, tolerance, method1, method2) {
    # Initialize variables
    time = begin_time
    result_state = c(initial_state)
    result_time = c(time)
    current_state = initial_state

    # Simulation loop
    while(time < end_time) {
        dt = dt_start
        while (compare_methods_reservoir(current_state, dt, area, alpha, method1, method2) > tolerance) {
            dt = dt * factor
        }
        current_state = method1(current_state, dt, area, alpha)
        result_state = c(result_state, current_state)
        time = time + dt
        result_time = c(result_time, time)
    }

    return(list(time = result_time, state = result_state))
}

# Define the parameters
begin_time = 0
end_time = 50
dt_start   = 5
initial_state = 3
A = 4.0
alpha = 1.5
factor = 0.8
tolerance = 0.01

# Run the simulation
simulation_results = simulate_reservoir(begin_time, end_time, dt_start, initial_state, A, alpha, factor, tolerance, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

# Extract results for plotting and further analysis
result_time = simulation_results$time
result_state = simulation_results$state


# Analytical solution
time_sequence = seq(begin_time,end_time, by=0.1)
analytic_state=initial_state * exp(-time_sequence*alpha/A)

# state of analytical solution to compare with numerical solution at every time step
analytic_state_at_discrete_time_step=initial_state * exp(-result_time*alpha/A)

# state of analytical to be compatiable with Isa's solution
analyt.state=initial_state * exp(-result_time*alpha/A)

# Plotting
plot(result_time, result_state,type='o', xlab="time", ylab="state", col="blue")
lines(result_time, analytic_state_at_discrete_time_step, col='grey', lwd=2)
title(main='Emptying reservoir')
grid()

# Number of function evaluations
num_eval = length(result_time)

#global_truncation_error = 

# Error at each time step
analytical_comparison = abs(analytic_state_at_discrete_time_step - result_state)

# Root-mean-square deviation
RMSD = sqrt(sum(analytical_comparison^2)/length(analytical_comparison))
print(paste("The root mean square deviation is:", RMSD))
```

Calculate total error in the whole domain
```{R}
# Install package for area under curve
if (!"DescTools" %in% installed.packages()) {install.packages("DescTools")}
library(DescTools)

# Calculate with area under curve
area_under_numercial_curve = AUC(result_time, result_state)
area_under_analytical_curve = AUC(time_sequence, analytic_state)
print(paste0("The absolute and percentage difference between analytical and numerical solution is: ", 
            abs(area_under_numercial_curve - area_under_analytical_curve), " and ", 
            abs(area_under_numercial_curve - area_under_analytical_curve) / area_under_analytical_curve * 100, "%"))
print(paste("The number of evaluations is", num_eval))
```
```{r}
# Approxfunction 
approx_time = c(1:50)

factor = 0.8
tolerance = 0.01
# Initial parameter values
begin_time = 0     # usually this variable is set to 0
end_time   = 50    # end time of the simulation 
dt_start   = 5   # delta t; time discretisation 
initial_state = 3     # state of the system at the beginning of the simulation 

# reservoir parameter values
A         = 4.0   # area
alpha     = 1.5  # decay constant

# Run the simulation
base_simulation_results = simulate_reservoir(begin_time, end_time, dt_start, initial_state, A, alpha, factor, tolerance, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

# Determine number of evaluration and runs needed 
base_num_eval = length(base_simulation_results$time)
print(paste("Number of evaluations for base=", base_num_eval))
print(paste("Number of runs for base=",base_simulation_results$runs))

# Appromixate the function 
approx_fun_base = approxfun(base_simulation_results$time,base_simulation_results$state)
approx_base_results = approx_fun_base(approx_time)

## ------------------------------ LOCAL SENSITIVTY ANALYSIS ------------------------------- ##

# Base 
base= list(initial_state = initial_state,A=A,alpha=alpha,tolerance=tolerance,factor=factor, dt_start = dt_start)
str(base)

# define scale of variation # dt_start?
scale= list(initial_state = 0.05 *initial_state,
            A = 0.05 * A,
            alpha = 0.05 * alpha,
            tolerance = 0.05 * tolerance,
            factor = 0.05*factor, 
            dt_start = 0.005 * dt_start)

#Define an epsion value 
eps = 1e-3

## ---------------------------- INITIAL VALUE ------------------------------------##

# Sensitivity of init.state
initial_state=base$initial_state+eps*base$initial_state

# Run model 
sens_simulation_results = simulate_reservoir(begin_time, end_time, dt_start, initial_state, A, alpha, factor, tolerance, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

## approximate function
approx_fun_sens =approxfun(sens_simulation_results$time,sens_simulation_results$state)
approx_sens_results = approx_fun_sens(approx_time)

## Caputre number of runs and evaluations
num_eval_initial_state = length(sens_simulation_results$time)
print(paste("Number of evaluations for intial value=", num_eval_initial_state))
runs_intial_value = sens_simulation_results$runs
print(paste("Number of runs for initial value=",sens_simulation_results$runs))

# Reset the base values 
initial_state=base$initial_state

#Find the local slope for the states
dStates_dinitstate = (approx_sens_results - approx_base_results)/(eps*base$initial_state)
#Plot 
plot(approx_time,dStates_dinitstate,type="l",lwd=3,col="blue",main="d{state}/d{init.state}")
abline(h=0,col="red",lwd=3)
grid(col="black")
# Plot
plot(sens_simulation_results$time, sens_simulation_results$state,type='o', xlab="time", ylab="state")
lines(base_simulation_results$time, analyt.state, col='grey', lwd=2)
title(main='Emptying reservoir')
grid()

## ---------------------------- ALPHA ------------------------------------##

# Sensitivity of init.state
alpha=base$alpha+eps*base$alpha

# Run model 
sens_simulation_results = simulate_reservoir(begin_time, end_time, dt_start,initial_state, A, alpha, factor, tolerance, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

## approximate function
approx_fun_sens =approxfun(sens_simulation_results$time,sens_simulation_results$state)
approx_sens_results = approx_fun_sens(approx_time)

# Number of runs 
num_eval_alpha = length(sens_simulation_results$time)
print(paste("Number of evaluations for alpha =", num_eval_alpha))
runs_alpha = sens_simulation_results$runs
print(paste("Number of runs for alpha =",runs_alpha))

# Reset the base values 
alpha=base$alpha

#Find the local slope for the states
dStates_dAlpha  = (approx_sens_results - approx_base_results)/(eps*base$alpha)

#Plot 
plot(approx_time,dStates_dAlpha,type="l",lwd=3,col="blue",main="d{state}/d{Alpha}")
abline(h=0,col="red",lwd=3)
grid(col="black")

## ---------------------------- A ------------------------------------##

# Sensitivity of init.state
A=base$A+eps*base$A

# Run model 
sens_simulation_results = simulate_reservoir(begin_time, end_time, dt_start,initial_state, A, alpha, factor, tolerance, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

## approximate function
approx_fun_sens =approxfun(sens_simulation_results$time,sens_simulation_results$state)
approx_sens_results = approx_fun_sens(approx_time)

# Number of runs 
num_eval_A = length(sens_simulation_results$time)
print(paste("Number of evaluations for A=", num_eval_A ))
runs_A = sens_simulation_results$runs
print(paste("Number of runs for A =",runs_A))

# Reset the base values 
A=base$A

#Find the local slope for the states
dStates_dA = (approx_sens_results - approx_base_results)/(eps*base$A)

#Plot 
plot(approx_time,dStates_dA,type="l",lwd=3,col="blue",main="d{state}/d{A}")
abline(h=0,col="red",lwd=3)
grid(col="black")


## ---------------------------- TOLERANCE ------------------------------------##

# Sensitivity of init.state
tolerance =base$tolerance +eps*base$tolerance 

# Run model 
sens_simulation_results = simulate_reservoir(begin_time, end_time, dt_start, initial_state, A, alpha, factor, tolerance, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

## approximate function
approx_fun_sens =approxfun(sens_simulation_results$time,sens_simulation_results$state)
approx_sens_results = approx_fun_sens(approx_time)

# Number of runs 
num_eval_tolerance = length(sens_simulation_results$time)
print(paste("Number of evaluations for A=", num_eval_tolerance))
runs_tolerance = sens_simulation_results$runs
print(paste("Number of runs for tolerance =",runs_tolerance))

# Reset the base values 
tolerance =base$tolerance 

#Find the local slope for the states
dStates_dTolerance = (approx_sens_results - approx_base_results)/(eps*base$tolerance )

#Plot 
plot(approx_time,dStates_dTolerance,type="l",lwd=3,col="blue",main="d{state}/d{tolerance}")
abline(h=0,col="red",lwd=3)
grid(col="black")

## ---------------------------- factor ------------------------------------##

# Sensitivity of init.state
factor =base$factor + eps*base$factor 

# Run model 
sens_simulation_results = simulate_reservoir(begin_time, end_time, dt_start, initial_state, A, alpha, tolerance, factor, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

## approximate function
approx_fun_sens =approxfun(sens_simulation_results$time,sens_simulation_results$state)
approx_sens_results = approx_fun_sens(approx_time)

# Number of factor 
num_eval_factor = length(sens_simulation_results$time)
print(paste("Number of evaluations for factor=", num_eval_factor ))
runs_factor = sens_simulation_results$runs
print(paste("Number of runs for factor =",runs_factor))

# Reset the base values 
factor =base$factor 

#Find the local slope for the states
dStates_dfactor = (approx_sens_results - approx_base_results)/(eps*base$factor)

#Plot 
plot(approx_time,dStates_dfactor,type="l",lwd=3,col="blue",main="d{state}/d{factor}")
abline(h=0,col="red",lwd=3)
grid(col="black")

## ---------------------------- dt START------------------------------------##

# Sensitivity of init.state
factor =base$dt_start +eps*base$dt_start 

# Run model 
sens_simulation_results = simulate_reservoir(begin_time, end_time, dt_start, initial_state, A, alpha, tolerance, factor, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

## approximate function
approx_fun_sens =approxfun(sens_simulation_results$time,sens_simulation_results$state)
approx_sens_results = approx_fun_sens(approx_time)

# Number of runs 
num_eval_dt = length(sens_simulation_results$time)
print(paste("Number of evaluations for dt=", num_eval_dt ))
runs_dt = sens_simulation_results$runs
print(paste("Number of runs for dt =",runs_dt))

# Reset the base values 
dt_start  =base$dt_start  

#Find the local slope for the states
dStates_dDt_start  = (approx_sens_results - approx_base_results)/(eps*base$dt_start)

#Plot 
plot(approx_time,dStates_dDt_start,type="l",lwd=3,col="blue",main="d{state}/d{dt_start}")
abline(h=0,col="red",lwd=3)
grid(col="black")

```

```{r}
 ## --------------------------- SENSITIVITY ANALYSIS ------------------------------

varState.initial_state = (scale$initial_state*dStates_dinitstate)^2
varState.alpha = (scale$alpha*dStates_dAlpha)^2
varState.A  = (scale$A*dStates_dA)^2
varState.tolerance= (scale$tolerance*dStates_dTolerance)^2
varState.factor = (scale$factor*dStates_dfactor)^2
varState.dt_start = (scale$dt_start*dStates_dDt_start)^2

#Separate Physical and Model parameters
varStateTotPhysical = varState.initial_state + varState.alpha + varState.A
varStateTotModel = varState.tolerance+ varState.factor + varState.dt_start

#Plot the scale of variation of the states over the whole domain:
plot(approx_time,sqrt(varStateTotPhysical),type="l",col="blue",lwd=3,
     ylab="standard deviation [m]",xlab="x",main="Total scale of variation of water levels")
grid(col="black")

plot(approx_time,sqrt(varStateTotModel),type="l",col="blue",lwd=3,
     ylab="standard deviation [m]",xlab="x",main="Total scale of variation of water levels")
grid(col="black")
```

```{r}

### LOCACL SENSITIVTY ANALYSIS: PLOT FIGURES FOR RELATIVE CONTIRBUTION TO VARIANCE 

##   -------------------------- Physical parameters  -----------------------------------  ##

## Plot with lines
plot(approx_time,rep(1,length(approx_time)),ylim=c(0,1),type="l",
     ylab="relative contribution to variance",xlab="time",
     main="Contribution to scale of variation of groundwater levels")
cols = rainbow(3)
lines(approx_time,varState.initial_state/varStateTotPhysical,col=cols[1],lwd=2)
lines(approx_time,varState.alpha/varStateTotPhysical,col=cols[2],lwd=2)
lines(approx_time,varState.A/varStateTotPhysical,col=cols[3],lwd=2)
legend("center", bty="n",
   legend=c("Initial state","Alpha","A"),lty=1,col=cols,
   horiz=TRUE)

## Plot stacked bar charts 
library(ggplot2)
# create a data set
condition <- (c(rep("Initial state", length(approx_time)), rep("Alpha", length(approx_time)), rep("A", length(approx_time))))
value <- c(abs(varState.initial_state/varStateTotPhysical), abs(varState.alpha/varStateTotPhysical), abs(varState.A/varStateTotPhysical))
data <- data.frame(approx_time,condition,value)
# Stacked bar chart 
ggplot(data, aes(fill=condition, y=value, x=approx_time)) + 
    geom_bar(position="stack", stat="identity", width=0.8) + ggtitle("Relative contribution to variance for physical parameters") + xlab("Time") + ylab("Relative contribution to variance")

##  ------------------------------- Model parameters  -----------------------------------  ##

## Plot with lines
plot(approx_time,rep(1,length(approx_time)),ylim=c(0,1),type="l",
     ylab="relative contribution to variance",xlab="time",
     main="Contribution to scale of variation of groundwater levels")
cols = rainbow(3)
lines(approx_time,varState.tolerance/varStateTotModel,col=cols[1],lwd=2)
lines(approx_time,varState.factor/varStateTotModel,col=cols[2],lwd=2)
lines(approx_time,varState.dt_start/varStateTotModel,col=cols[3],lwd=2)
legend("center", bty="n",
   legend=c("Tolerance","Factor","Reference dt"),lty=1,col=cols,
   horiz=TRUE)

## Plot with barchart
library(ggplot2)
# create a dataset
condition <- (c(rep("tolerance", length(approx_time)), rep("factor", length(approx_time)), rep("dt start", length(approx_time))))
value <- c(abs(varState.tolerance/varStateTotModel), abs(varState.factor/varStateTotModel), abs(varState.dt_start/varStateTotModel))
data <- data.frame(approx_time,condition,value)
# Stacked
ggplot(data, aes(fill=condition, y=value, x=approx_time)) + 
    geom_bar(position="stack", stat="identity", width=0.8) + ggtitle("Relative contribution to variance for model parameters") + xlab("Time") + ylab("Relative contribution to variance")

```



# Global sensitivity analysis
```{R}
source("samplehelpers.R")

base_global = list(A = A, alpha = alpha)
scale_global = list(A = 0.05 * A, alpha = 0.05 * alpha)

parnames = names(base_global)
parmeans = unlist(base_global)
parsd    = unlist(scale_global)

parlower = c(3.5, 1)
parupper = c(4.5, 2)
samplesize = 100
set.seed(237)
parsample = GaussianLHS(samplesize,parmeans,parsd,parnames,parlower,parupper) 

head(parsample)
summary(parsample)
plot(parsample,cex=0.4)

old.par = par(no.readonly=TRUE)
par(mfrow=c(1,2))
hist(parsample[,"A"],main="",col="lightblue",prob=TRUE)
rug(parsample[,"A"],col="red")
lines(density(parsample[,"A"]),col="red",lwd=2)
hist(parsample[,"alpha"],main="",col="lightblue",prob=TRUE)
rug(parsample[,"alpha"],col="red")
lines(density(parsample[,"alpha"]),col="red",lwd=2)
```

```{R}
statesSample = matrix(0,ncol=length(result_time),nrow=0)
timeSample = matrix(0,ncol=length(result_time),nrow=0)

# Define the parameters
begin_time = 0
end_time = 50
dt_start = 5
initial_state = 3
factor = 0.8
tolerance = 0.01

# point to evaluate
points_for_evaluation = c(0:50)

simulation_results_approx = matrix(0,ncol=length(points_for_evaluation),nrow=0)

# start the for-loop through the parameter sample 
for(i in 1:nrow(parsample))
  {
    A = parsample[i,"A"] 
    alpha = parsample[i,"alpha"]
    
# Run the simulation
simulation_results = simulate_reservoir(begin_time, end_time, dt_start, initial_state, A, alpha, factor, tolerance, calculate_euler_forward_reservoir, calculate_heuns_reservoir)

# Extract results for plotting and further analysis
result_time = simulation_results$time
result_state = simulation_results$state

linear_interpolation = approxfun(result_time, result_state)
simulation_results_approx = rbind(simulation_results_approx,linear_interpolation(points_for_evaluation))

# Analytical solution
time_sequence = seq(begin_time,end_time, by=0.1)
analytic_state=initial_state * exp(-time_sequence*alpha/A)

# state of analytical solution to compare with numerical solution at every time step
analytic_state_at_discrete_time_step=initial_state * exp(-result_time*alpha/A)

# Plotting
# plot(result_time, result_state,type='o', xlab="time", ylab="state", col="blue")
# lines(result_time, analytic_state_at_discrete_time_step, col='grey', lwd=2)
# title(main='Emptying reservoir')
# grid()

# Number of function evaluations
num_eval = length(result_time)

# Error at each time step
analytical_comparison = abs(analytic_state_at_discrete_time_step - result_state)

# Root-mean-square deviation
RMSD = sqrt(sum(analytical_comparison^2)/length(analytical_comparison))
print(paste("The root mean square deviation is:", RMSD))
print(paste("The number of evaluations is", num_eval))
statesSample = rbind(statesSample,simulation_results$state)
timeSample = rbind(timeSample,simulation_results$time)
  }

```

```{R}
# Install package 
if (!"matrixStats" %in% installed.packages()) {install.packages("matrixStats")}
library(matrixStats)
matplot(t(timeSample),t(statesSample),type="l",main="States for all parameter sets",ylab="water level")
matplot(points_for_evaluation,t(simulation_results_approx),type="l",main="States for all parameter sets",ylab="water level")
```

```{r, animation.hook="gifski", interval = 0.3}

for (i in c(2:length(points_for_evaluation))) {
  MPsample = cbind(M=simulation_results_approx[,i],parsample)
  plot(MPsample[,"A"], MPsample[,"M"], main=paste("Value of A versus model results with conditional expectation at t =", i-1), ylim = c(0,3))
  McondA = linloess(M~A,data=MPsample)
  points(MPsample[,"A"],McondA,pch=20,col="red")
}
```


```{r, animation.hook="gifski", interval = 0.3}

for (i in c(2:length(points_for_evaluation))) {
  MPsample = cbind(M=simulation_results_approx[,i],parsample)
  plot(MPsample[,"alpha"], MPsample[,"M"], main=paste("Value of alpha versus model results with conditional expectation at t =", i-1), ylim = c(0,3))
  Mcondalpha = linloess(M~alpha,data=MPsample)
  points(MPsample[,"alpha"],Mcondalpha,pch=20,col="red")
}

```





```{R, animation.hook="gifski", interval = 0.3}
variance_A = c()
variance_alpha = c()
variance_model = c()
  
for (i in c(2:length(points_for_evaluation))) {
  MPsample = cbind(M=simulation_results_approx[,i],parsample)
  VARM = var(simulation_results_approx[,i])
  variance_model = c(variance_model, VARM)
  SDM = sd(simulation_results_approx[,i])
  ANOVA1 = sample.vardecomp(MPsample)
  variance_A = c(variance_A, ANOVA1[[1]])
  variance_alpha = c(variance_alpha, ANOVA1[[2]])
  
  added_var <- 0
  for (j in c(1:length(ANOVA1))) {
  added_var <- added_var + ANOVA1[j]
}
  pie(ANOVA1,
    main=paste("Variance of M =", VARM, "at t =", i-1, 
               "\nRemaining variance is", VARM - added_var),
    col = rainbow(5),
    radius=1)
}

if (!"ggplot2" %in% installed.packages()) {install.packages("ggplot2")}
library(ggplot2)

# create a dataset
condition <- (c(rep("A", length(points_for_evaluation) - 1), rep("alpha", length(points_for_evaluation) - 1)))
value <- c(abs(variance_A/variance_model), abs(variance_alpha/variance_model))
time <- c(1:(length(points_for_evaluation)-1), 1:(length(points_for_evaluation)-1)) 
data <- data.frame(time, condition, value) 

# Stacked
ggplot(data, aes(fill=condition, y=value, x=time)) +
  geom_bar(position="stack", stat="identity")

temp_data = data.frame(time = c(1:(length(points_for_evaluation)-1)), model_variance = variance_model)
ggplot(temp_data,  aes(y=model_variance, x=time)) +
  geom_line()
```




#variable time-stepping Hupsel
```{r}
##loading input and observed data
hupsel_dat = read.table(file='hupsel.dat')
hupsel_time = hupsel_dat$V1
hupsel_Qin = hupsel_dat$V2
hupsel_Qobs = hupsel_dat$V3
#to make data continuous for al dt
approximate_Qin =approxfun(x=hupsel_time,y=hupsel_Qin,rule=2:2) 
approximate_Qobs = approxfun(x=hupsel_time,y=hupsel_Qobs,rule = 2:2)

calculate_water_level_hupsel = function(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up){
  if(state <= res_lvl_up){
    state = (approximate_Qin(time)/area) - (res_alpha_lw*state)/area
  }
  else{
    state = (approximate_Qin(time) - (res_alpha_lw*state) - res_alpha_up*(state-res_lvl_up))/area
  }
  return(state)
  }

# Function: calculate_euler_forward_hupsel
#
# Purpose:
#   Calculates the next state of the system using the Euler Forward method.
#
# Parameters:
#   state - The current state of the system (numeric).
#   dt    - The time step to be used for calculation (numeric).
#   A     - The area parameter of the reservoir (numeric).
#   alpha - The decay constant (numeric).
#
# Returns:
#   The next state of the system after applying the Euler Forward method (numeric).

calculate_euler_forward_hupsel = function(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up) {
    forward = state + dt * calculate_water_level_hupsel(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
    return(forward)
}


# Function: calculate_heuns_method
#
# Purpose:
#   Calculates the next state of the system using Heun's method.
#
# Parameters:
#   state - The current state of the system (numeric).
#   dt    - The time step to be used for calculation (numeric).
#   A     - The area parameter of the reservoir (numeric).
#   alpha - The decay constant (numeric).
#
# Returns:
#   The next state of the system after applying Heun's method (numeric).

calculate_heuns_hupsel = function(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up) {
    s_tilde = state + dt * calculate_water_level_hupsel(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
    heuns = state + dt / 2 * (calculate_water_level_hupsel(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up) + calculate_water_level_hupsel(time, s_tilde, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)) 
    return(heuns)
}

#system function
calculate_rk4_hupsel = function(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
{
        k1 = dt*calculate_water_level_hupsel(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k2 = dt*calculate_water_level_hupsel(time + dt / 5, state+ k1 / 5, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up) 
        k3 = dt*calculate_water_level_hupsel(time + 3/10*dt,state+ 3/40*k1+9/40*k2, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k4 = dt*calculate_water_level_hupsel(time + 3/5*dt, state+3/10*k1-9/10*k2+6/5*k3, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k5 = dt*calculate_water_level_hupsel(time + 1/1*dt, state-11/54*k1+5/2*k2-70/27*k3+35/27*k4, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k6 = dt*calculate_water_level_hupsel(time + 7/8*dt, state+1631/55296*k1+175/512*k2+575/13824*k3+44275/110592*k4+253/4096*k5, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        newstate4 = state + 37/378*k1+250/621*k3+125/594*k4+512/1771*k6
        return(newstate4)
}

calculate_rk5_hupsel = function(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
{
        k1 = dt*calculate_water_level_hupsel(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k2 = dt*calculate_water_level_hupsel(time + dt / 5, state+ k1 / 5, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up) 
        k3 = dt*calculate_water_level_hupsel(time + 3/10*dt,state+ 3/40*k1+9/40*k2, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k4 = dt*calculate_water_level_hupsel(time + 3/5*dt, state+3/10*k1-9/10*k2+6/5*k3, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k5 = dt*calculate_water_level_hupsel(time + 1/1*dt, state-11/54*k1+5/2*k2-70/27*k3+35/27*k4, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        k6 = dt*calculate_water_level_hupsel(time + 7/8*dt, state+1631/55296*k1+175/512*k2+575/13824*k3+44275/110592*k4+253/4096*k5, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
        newstate5 = state + 2825/27648*k1+18575/48384*k3+13525/55296*k4+277/14336*k5+1/4*k6
        return(newstate5)
}


# Function: compare_methods
#
# Purpose:
#   Compares the results of the Euler Forward method and Heun's method to determine
#   the difference between these two approaches for a given state and time step.
#
# Parameters:
#   state - The current state of the system (numeric).
#   dt    - The time step to be used for calculation (numeric).
#   A     - The area parameter of the reservoir (numeric).
#   alpha - The decay constant (numeric).
#
# Returns:
#   The absolute difference between the results of the Euler Forward method
#   and Heun's method (numeric).

# compare_methods = function(state, dt=dt, area=A, alpha=alpha) {
#     euler_forward = calculate_euler_forward_method(state, dt, A, alpha)
#     heuns_method = calculate_heuns_method(state, dt, A, alpha)
#     difference = abs(heuns_method - euler_forward)
#     return(difference)
# }

compare_methods_hupsel = function(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up, method1, method2) {
    result_method1 = method1(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
    result_method2 = method2(time, state, dt, area, res_alpha_lw, res_alpha_up, res_lvl_up)
    difference = abs(result_method1 - result_method2)
    return(difference)
}


simulate_hupsel = function(begin_time, end_time, dt_start, initial_state, area, alpha_lower, alpha_upper, level_upper, factor, tolerance, method1, method2) {
    # Initialize variables
    time = begin_time
    result_state = c(initial_state)
    result_time = c(time)
    current_state = initial_state
    result_Qout1    = c()
    result_Qout2    = c()
    result_Qin      = c()

    # Simulation loop
    while(time < end_time) {
        dt = dt_start
        #dt = factor * dt * (tol/abs(sys.fun_CK4(current.state) - sys.fun_CK5(current.state)))^1/5
        while (compare_methods_hupsel(time, current_state, dt, area, alpha_lower, alpha_upper, level_upper, method1, method2) > tolerance) {
            iterations = iterations + 1
            dt = dt * factor
        }
        iterations = iterations + 1
        current_state = method1(time, current_state, dt, area, alpha_lower, alpha_upper, level_upper)
        result_state = c(result_state, current_state)
        time = time + dt
        result_time = c(result_time, time)
    }

    return(list(time = result_time, state = result_state))
}
#####Calculation of the Qout fluxes
##first a function (state.above.up) to determine which states are above the upper outlet
calculate_water_level_above_upper = function(res_lvl_up)
{
  water_level_above_upper = c()
  for (i in 1:length(simulation_hepsel_results$time))
  {
    current_water_level = simulation_hepsel_results$state[i]
   if(current_water_level>res_lvl_up)
   {
     water_level_above_upper=c(water_level_above_upper,current_water_level)
   }else{
     water_level_above_upper=c(water_level_above_upper,0)
   }
  }
  return(water_level_above_upper)
}

##time aspects
begin_time   = 0              #begin time of the simulation
end_time = tail(hupsel_time, 1) #end time of the simulation
dt_start     = 2           #1.0#.5 #delta t; time discretisation

#reservoir parameters
res_alpha_lw = 0.10543215 
res_alpha_up = 0.75
res_lvl_up   = 0.4            #1.7
res_A        = 1.45 

init_state   = 0.5            #the initial state of the linear reservoir

tolerance = 10^-4
factor = 0.8
iterations = 0

simulation_hepsel_results = simulate_hupsel(begin_time, end_time, dt_start, init_state, res_A, res_alpha_lw, res_alpha_up, res_lvl_up, factor, tolerance, calculate_rk4_hupsel, calculate_rk5_hupsel)

  water_level_above_upper =calculate_water_level_above_upper(res_lvl_up)  
  Qout_upper = water_level_above_upper
  IQout = which(water_level_above_upper>0)
  Qout_upper[IQout] = res_alpha_up*(Qout_upper[IQout]-res_lvl_up) 
 
  
#   Qout.up = res.alpha.up*(state.above[state.above>0]-res.lvl.up)

Qout_lower = c()
Qout_lower = res_alpha_lw*simulation_hepsel_results$state
# Qout.lw = res.A*res.k.lw*result.state

##balance
##dV/dt = Qin - Qout.lw - Qout.up
##dV/dt = state*res.A/dt
nrsteps = length(simulation_hepsel_results$state)-1
dVdt = diff(simulation_hepsel_results$state)*res_A/dt_start # unsure, was dt before
Qin = approximate_Qin(simulation_hepsel_results$time)
error = Qin[1:nrsteps] - Qout_lower[1:nrsteps] - Qout_upper[1:nrsteps] - dVdt
 
plot(simulation_hepsel_results$time,Qin,type = 'l',
     ylim=c(min(Qin,Qout_lower,Qout_upper,dVdt),max(Qin,Qout_lower,Qout_upper,dVdt)),
     ylab = 'L^3/T',xlab = 'time')
legend('topleft',c('Qin : black',
                 'Qout.lw : blue',
                 'Qout.up : green',
                 'dVdt: red',
                 'error : dashed'))

     
lines(simulation_hepsel_results$time[1:nrsteps],dVdt,col='red')
lines(simulation_hepsel_results$time[1:nrsteps],Qout_lower[1:nrsteps],col='blue')
lines(simulation_hepsel_results$time[1:nrsteps],Qout_upper[1:nrsteps],col='green')
lines(simulation_hepsel_results$time[1:nrsteps],error,lty='dashed')

##results observed vs computed
plot(simulation_hepsel_results$time[1:nrsteps],approximate_Qobs(simulation_hepsel_results$time[1:nrsteps]),type='l',
     lwd=2,col='grey',ylim=c(min(hupsel_Qobs,Qout_lower,Qout_upper),max(hupsel_Qobs,Qout_lower,Qout_upper)),
     ylab = 'Qout.obs/Qout.calc',xlab = 'time')
lines(simulation_hepsel_results$time[1:nrsteps],Qout_upper[1:nrsteps]+Qout_lower[1:nrsteps],col='blue')

RMSE = sqrt(mean((approximate_Qobs(simulation_hepsel_results$time)-(Qout_upper+Qout_lower))^2))
mean_obs = mean(approximate_Qobs(simulation_hepsel_results$time))
obs_var = sum((approximate_Qobs(simulation_hepsel_results$time) - mean_obs)^2)
NSE = 1-(sum((approximate_Qobs(simulation_hepsel_results$time)-(Qout_upper+Qout_lower))^2)/obs_var)
title(main=paste('Original time-stepping','RMSE = ',round(RMSE,digits=3), '\n NSE = ', round(NSE, digits = 2)))

```

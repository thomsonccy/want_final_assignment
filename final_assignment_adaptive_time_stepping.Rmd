---
title: "Final assignment: Adaptive Time Stepping"
author: "The WANT team"
date: "19/01/2020"
output:
  html_document:
    css: want.css
    toc: yes
    toc_depth: 1
---


# Introduction
During the exercises on Finite Differences, you have experienced several times that the model can become instable or at least can start oscillating. Often, this could be resolved with decreasing the time step over which the calculation was performed. This is, however, a rather expensive solution, because a smaller time step means many more calculations while maybe, this smaller time step is not needed throughout the complete simulation period. Therefore, adaptive time stepping schemes exist; when needed, a smaller time step is taken, and when not needed, the time step is increased again.  

# The model 
We will implement an adaptive time stepping scheme for the most simple model we dealt with; the emptying reservoir without input. 

![](reservoir_properties.png)



*Single linear reservoir with outlet properties.*  

# First assignment
Implement an adaptive time stepping scheme. For this, you have to define criteria for when the time step has to decrease (and how much). This can be based on the difference between two schemes. However, you don't want to do the same calculation twice, because then you might as well half the step size directly. Therefore, use two schemes where one scheme is an intergral part of the other scheme. The simplest example is Euler Forward and Heun's Method. Heun's Method looks as follows:

$$\widetilde{s}= s(t) + \Delta t f(t,s(t))$$

Where $\tilde{s}$ is a sub-step equal to Euler Forward. Subsequently, $t+\Delta t$ is obtained as:
$$ s(t+\Delta t)= s(t) + \frac{\Delta t}{2}(f(t,s(t))+f(t+\Delta t,\widetilde{s}))$$


Another option is for instance the Cash-Karp method, where two Runge-Kutta schemes are compared. Implement the schemes, define an error tolerance, and adapt the time step when the error exceeds this tolerance. Compare your results to the analytical solution, to evaluate the trade-off between error and number of evaluations-. 

# Second assignment
Conduct a sensitivity analysis. 
- Decide for yourself whether you want to conduct a local or global sensitivity analysis.
- Decide on which parameters you want to conduct sensitivity analysis - the parameters from the reservoir, or the parameters of your adaptive time stepping scheme, or both and their interaction? 

# Further exploration
You are free to explore any other questions that arise with the model. For example:
- Use variable input, such as the Hupsel data from assignment 6, week 1. What are the water balance errors and do these decrease with a variable time stepping scheme? 
- What happens to the results if you add complexity to my model? (e.g. by introducing a second outlet)
- What is the relation between time steps and parameter sensitivity?

$$s(t + \Delta t)=s(t)+\dfrac{\Delta t}{A}
\left(Q_{in}-\alpha_{res.up}(s(t)-level_{res.up})-\alpha_{res.lw}\:s(t)\right)\\$$



```{R}
# Calculate water level in reservoir using Euler Forward and Heun's Method
# Compare the absolute difference between Euler Forward and Heun's Method
# If difference is smaller than tolerance, the result from Heun's method is accepted
# If difference is larger than tolerance, it recalculates using 
# new time step = old time step * factor
# until the difference is smaller than tolerance

calculate_euler_forward_method = function(state) {
    forward = state + dt/A *(-alpha * state)
    return(forward)
}

calculate_heuns_method = function(state) {
    s_tilde= state + dt/A *(-alpha * state)
    newstate = state + dt/(2*A) *((-alpha*state)  - alpha * s_tilde) 
    return(newstate)
}

# Initial parameter values
begin_time = 0     # usually this variable is set to 0
end_time   = 50    # end time of the simulation 
dt_start   = 5   # delta t; time discretisation 
initial_state = 3     # state of the system at the beginning of the simulation 

# reservoir parameter values
A         = 4.0   # area
alpha     = 1.5  # decay constant

# variable time-step parameter values
factor = 0.95
tolerance = 0.01

# Simulation initialisation
time = begin_time
result_state = c(initial_state)
result_time = c(time)
current_state = initial_state

# Simulation
while(time < end_time) {
  dt = dt_start
  while (abs(calculate_heuns_method(current_state) - calculate_euler_forward_method(current_state)) > tolerance) {
    dt = dt*factor 
  }
  current_state = calculate_heuns_method(current_state)
  result_state = c(result_state,current_state)
  time = time + dt
  result_time = c(result_time,time)
}

# Analytical solution
time_sequence = seq(begin_time,end_time, by=0.1)
analytic_state=initial_state * exp(-time_sequence*alpha/A)

# state of analytical solution to compare with numercial solution at every time step
analytic_state_at_discrete_time_step=initial_state * exp(-result_time*alpha/A)

# Plotting
plot(result_time, result_state,type='o', xlab="time", ylab="state", col="blue")
lines(result_time, analytic_state_at_discrete_time_step, col='grey', lwd=2)
title(main='Emptying reservoir')
grid()

# Number of function evaluations
num_eval = length(result_time)

#global_truncation_error = 

# Error per time-step
analytical_comparison = abs(analytic_state_at_discrete_time_step - result_state)

# Root-mean-square deviation
RMSD = sqrt(sum(analytical_comparison^2)/length(analytical_comparison))
print(paste("The root mean square deviation is:", RMSD))
```

Calculate total error in the whole domain
```{R}
# Install package for area under curve
if (!"DescTools" %in% installed.packages()) {install.packages("DescTools")}
library(DescTools)

# Calculate with area under curve
area_under_numercial_curve = AUC(result_time, result_state)
area_under_analytical_curve = AUC(time_sequence, analytic_state)
print(paste0("The absolute and percentage difference between analytical and numerical solution is: ", 
            abs(area_under_numercial_curve - area_under_analytical_curve), " and ", 
            abs(area_under_numercial_curve - area_under_analytical_curve) / area_under_analytical_curve * 100, "%"))
print(paste("The number of evaluations is", num_eval))
```
# Calculate sum of squares
```{R}
()

```


# Cash-Karp method
```{r}

f = function(time, state){
  return((-alpha*state)/A)
}
#system function
sys.fun_CK4 = function(state)
{
        k1 = dt*f(time,state)
        k2 = dt*f(time+(1/5)*dt,state+((1/5)*k1)) 
        k3 = dt*f(time+(3/10)*dt,state+((3/40)*k1)+((9/40)*k2))
        k4 = dt*f(time+(3/5)*dt,state+((3/10)*k1)-((9/10)*k2)+((6/5)*k3))
        k5 = dt*f(time+(1/1)*dt,state-((11/54)*k1)+((5/2)*k2)-((70/27)*k3)+((35/27)*k4))
        k6 = dt*f(time+(7/8)*dt,state+((1631/55296)*k1)+((175/512)*k2)+((575/13824)*k3)+((44275/110592)*k4)+((253/4096)*k5))
        newstate4 = state + ((37/378)*k1)+((250/621)*k3)+((125/594)*k4)+((512/1771)*k6)
        return(newstate4)
}

sys.fun_CK5 = function(state)
{
        k1 = dt*f(time,state)
        k2 = dt*f(time+(1/5)*dt,state+((1/5)*k1)) 
        k3 = dt*f(time+(3/10)*dt,state+((3/40)*k1)+((9/40)*k2))
        k4 = dt*f(time+(3/5)*dt,state+((3/10)*k1)-((9/10)*k2)+((6/5)*k3))
        k5 = dt*f(time+(1/1)*dt,state-((11/54)*k1)+((5/2)*k2)-((70/27)*k3)+((35/27)*k4))
        k6 = dt*f(time+(7/8)*dt,state+((1631/55296)*k1)+((175/512)*k2)+((575/13824)*k3)+((44275/110592)*k4)+((253/4096)*k5))
        newstate5 = state + ((2825/27648)*k1)+((18575/48384)*k3)+((13525/55296)*k4)+((277/14336)*k5)+((1/4)*k6)
        return(newstate5)
}


# Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation 
dt_init   = 5  # delta t; time discretisation 
init.state = 3     # state of the system at the beginning of the simulation 

# reservoir parameter values
A         = 4.0   # area
alpha     = 1.5  # decay constant

# Simulation initialisation
time = begin.time
result.state = c(init.state)
result.time = c(time)
current.state = init.state

# Simulation
  tol = 10^-2
  factor = 0.9
  
while(time < end.time)
{ 
  dt = dt_init
  while(abs(sys.fun_CK4(current.state) - sys.fun_CK5(current.state))>tol){
    dt = factor * dt
    }
    current.state = sys.fun_CK4(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
}

# Analytical solution
time.sequence = seq(begin.time,end.time, by=0.1)
analyt.state=init.state * exp(-time.sequence*alpha/A)
analyt.state_compare = init.state * exp(-result.time*alpha/A)

# Plotting
plot(result.time, result.state,type='o', xlab="time", ylab="state")
lines(time.sequence, analyt.state, col='grey', lwd=2)
title(main='Emptying reservoir')
grid()

# Number of function evaluations
num_eval = length(result.time)

```


# With fixed input
```{R}
# System functions
g_explicit = function(time, state)
{
  return(state + dt/A*((sin(time)+1)-alpha*state))
}

g_implicit = function(time, state)
{
  return(state+dt/2*(((sin(time)+1-alpha*state)/A)+(sin(time)+1-alpha*g_explicit(time+dt,state))/A))
  
}

sys.fun = function(state)
{
  # s.aux    = g_explicit(time     , state)
  newstate = g_implicit(time, state)
  return(newstate)
}


# Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation 
dt         = 2.5   # delta t; time discretisation 
init.state = 3     # state of the system at the beginning of the simulation 

# reservoir parameter values
A         = 4.0   # area
alpha     = 1.5  # decay constant

# Simulation initialisation
time = begin.time
result.state = c(init.state)
result.time = c(time)
current.state = init.state

# Simulation
while(time < end.time)
{
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
}

# Analytical solution
# time.sequence = seq(begin.time,end.time, by=0.1)
# analyt.state=init.state * exp(-time.sequence*alpha/A)




# Plotting
plot(result.time, result.state,type='o', xlab="time", ylab="state")
lines(time.sequence, analyt.state, col='grey', lwd=2)
dt = 0.1 # a new dt value to evaluate current scheme
time = begin.time
result.state = c(init.state)
result.time = c(time)
current.state = init.state
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}
lines(result.time,result.state,type='o',col='blue', lwd=0.1)
title(main='Emptying reservoir with input')
grid()

# Number of function evaluations
num_eval = length(result.time)


```


#variable time-stepping Hupsel
```{r}
##loading input and observed data
hupsel = read.table(file='hupsel.dat')
hupsel.time = hupsel$V1
hupsel.Qin = hupsel$V2
hupsel.Qobs = hupsel$V3
#to make data continuous for al dt
Qin.fun =approxfun(x=hupsel.time,y=hupsel.Qin,rule=2:2) 
Qobs.fun = approxfun(x=hupsel.time,y=hupsel.Qobs,rule = 2:2)

##time aspects
begin.time   = 0              #begin time of the simulation
end.time = hupsel.time[length(hupsel.time)] #end time of the simulation
dt_init     = 2           #1.0#.5 #delta t; time discretisation

#reservoir parameters
res.alpha.lw = 0.10543215 
res.alpha.up = 0.75
res.lvl.up   = 0.4            #1.7
res.A        = 1.45 

init.state   = 0.5            #the initial state of the linear reservoir

f = function(time, state){
  if(state<= res.lvl.up){
    state = (Qin.fun(time)/res.A) - (res.alpha.lw*state)/res.A
  }
  else{
    state = (Qin.fun(time) - (res.alpha.lw*state) - res.alpha.up*(state-res.lvl.up))/res.A
  }
  return(state)
  }

#sys.fun = function(state)
#{
#  if(state<= res.lvl.up)
# {
#    state = state +dt/res.A*(Qin.fun(time)- res.alpha.lw*state)
#  }else{
#    state = state + dt/res.A*(Qin.fun(time)-res.alpha.up*(state-res.lvl.up)-res.alpha.lw*state)
#  }
#  return(state)
#}

time            = begin.time
result.state    = c(init.state)
result.time     = c(time)
current.state   = init.state
result.Qout1    = c()
result.Qout2    = c()
result.Qin      = c()

tol = 10^-4
factor = 0.8
iterations = 0

while(time < end.time)
{ 
  dt = dt_init
  while(abs(sys.fun_CK4(current.state) - sys.fun_CK5(current.state))>tol){
    iterations = iterations + 1
    dt = factor * dt
    #dt = factor * dt * (tol/abs(sys.fun_CK4(current.state) - sys.fun_CK5(current.state)))^1/5
  }
    iterations = iterations + 1
    current.state = sys.fun_CK4(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
}
#####Calculation of the Qout fluxes
##first a function (state.above.up) to determine which states are above the upper outlet
state.above.up = function()
{
  state.up = c()
  for (i in 1:length(result.time))
  {
    this.state = result.state[i]
   if(this.state>res.lvl.up)
   {
     state.up=c(state.up,this.state)
   }else{
     state.up=c(state.up,0)
   }
  }
  return(state.up)
}


  state.above =state.above.up()  
  Qout.up = state.above
  IQout = which(state.above>0)
  Qout.up[IQout] = res.alpha.up*(Qout.up[IQout]-res.lvl.up) 
 
  
#   Qout.up = res.alpha.up*(state.above[state.above>0]-res.lvl.up)

Qout.lw = c()
Qout.lw = res.alpha.lw*result.state
# Qout.lw = res.A*res.k.lw*result.state

##balance
##dV/dt = Qin - Qout.lw - Qout.up
##dV/dt = state*res.A/dt
nrsteps = length(result.state)-1
dVdt = diff(result.state)*res.A/dt
Qin = Qin.fun(result.time)
error = Qin[1:nrsteps] - Qout.lw[1:nrsteps] - Qout.up[1:nrsteps] - dVdt
 
plot(result.time,Qin,type = 'l',
     ylim=c(min(Qin,Qout.lw,Qout.up,dVdt),max(Qin,Qout.lw,Qout.up,dVdt)),
     ylab = 'L^3/T',xlab = 'time')
legend('topleft',c('Qin : black',
                 'Qout.lw : blue',
                 'Qout.up : green',
                 'dVdt: red',
                 'error : dashed'))

     
lines(result.time[1:nrsteps],dVdt,col='red')
lines(result.time[1:nrsteps],Qout.lw[1:nrsteps],col='blue')
lines(result.time[1:nrsteps],Qout.up[1:nrsteps],col='green')
lines(result.time[1:nrsteps],error,lty='dashed')

##results observed vs computed
plot(result.time[1:nrsteps],Qobs.fun(result.time[1:nrsteps]),type='l',
     lwd=2,col='grey',ylim=c(min(hupsel.Qobs,Qout.lw,Qout.up),max(hupsel.Qobs,Qout.lw,Qout.up)),
     ylab = 'Qout.obs/Qout.calc',xlab = 'time')
lines(result.time[1:nrsteps],Qout.up[1:nrsteps]+Qout.lw[1:nrsteps],col='blue')

RMSE = sqrt(mean((Qobs.fun(result.time)-(Qout.up+Qout.lw))^2))
mean_obs = mean(Qobs.fun(result.time))
obs_var = sum((Qobs.fun(result.time) - mean_obs)^2)
NSE = 1-(sum((Qobs.fun(result.time)-(Qout.up+Qout.lw))^2)/obs_var)
title(main=paste('Original time-stepping','RMSE = ',round(RMSE,digits=3), '\n NSE = ', round(NSE, digits = 2)))

```